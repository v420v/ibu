#include "header.ibu"
#include "../util/header.ibu"
#include "../linux-syscall/header.ibu"

#define InitKind i32
#define InitKindNode 1
#define InitKindChildren 2

struct Initializer;
struct Initializer {
    kind InitKind,
    node *Node, // for InitKindNode
    children *Vec, // for InitKindChildren
    tok *Token,
}

func add_type(p *Parser, node *Node) u0;
func parse_ty(p *Parser) *Type;
func parse_expr(p *Parser) *Node;
func parse_stmt(p *Parser) *Node;
func cmp_type(ty1 *Type, ty2 *Type) bool;
func parse_unary(p *Parser) *Node;
func find_locals(p *Parser, tok *Token) *Object;
func scope_push_obj(p *Parser, name *u8, obj *Object) *VarScope;
func parser_skip(p *Parser, str *u8) u0;
func new_node(kind NodeKind) *Node;
func new_binop(kind NodeKind, lhs *Node, rhs *Node) *Node;
func new_node_num(n i32) *Node;
func new_struct_access_node(kind NodeKind, lhs *Node, offset i32, ty *Type) *Node;
func parser_next(p *Parser) u0;
func add_type(p *Parser, node *Node) u0;
func parse_expr(p *Parser) *Node;
func parse_expr_stmt(p *Parser) *Node;
func parse_block(p *Parser) *Node;
func node_true() *Node;

func internal_error() u0 {
    eprintf("internal error: this should not happen, please report a bug here https://github.com/v420v/vas/issues\n");
    exit(1);
}

func cmp_func_param(p1 *Object, p2 *Object) bool {
    return str_equal(p1.name, p2.name) && cmp_type(p1.ty, p2.ty);
}

func cmp_func_params(p1 *Vec, p2 *Vec) bool {
    if p1.len != p2.len {
        return false;
    }

    for let i i32 = 0; i < p1.len; i++ {
        if !cmp_func_param(vec_get(p1, i), vec_get(p2, i)) {
            return false;
        }
    }

    return true;
}

let unique_label_count i64 = 0;

func new_unique_label() *u8 {
    // i64 max value is 18446744073709551615 so 20 characters are enough
    let label *u8 = alloc(strlen(".L..") + 20 + 1);
    if label == nil {
        eprintf("memory allocation failed\n");
        exit(1);
    }
    sprintf(label, ".L..%d", unique_label_count++);
    return label;
}

func find_globals(p *Parser, tok *Token) *Object {
    for let object *Object = p.globals; object != nil; object = object.next {
        if is_token(tok, object.name) {
            return object;
        }
    }

    return nil;
}

func check_local_object_already_exist(p *Parser, name *u8, tok *Token) i32 {
    let obj *Object = find_locals(p, tok);
    if obj != nil {
        print_error_with_code(tok, "name already exist");
        exit(1);
    }
    return 0;
}

func new_local_object(p *Parser, kind ObjectKind, name *u8, ty *Type, tok *Token, is_func_param bool) *Object {
    check_local_object_already_exist(p, name, tok);

    let obj *Object = alloc(typesize(Object));
    if obj == nil {
        eprintf("memory allocation failed\n");
        exit(1);
    }

    obj.kind = kind;
    obj.name = name;
    obj.ty = ty;
    obj.is_func_param = is_func_param;

    obj.next = p.locals;
    p.locals = obj;

    scope_push_obj(p, name, obj);

    return obj;
}

func enter_scope(p *Parser) u0 {
    let new_scope *Scope = alloc(typesize(Scope));
    new_scope.outer = p.scope;
    p.scope = new_scope;
}

func leave_scope(p *Parser) u0 {
    p.scope = p.scope.outer;
}

func find_locals(p *Parser, tok *Token) *Object {
    for let scope *Scope = p.scope; scope != nil; scope = scope.outer {
        let var_scope *VarScope = scope.var_scope;
        while var_scope != nil {
            if is_token(tok, var_scope.name) {
                return var_scope.obj;
            }
            var_scope = var_scope.outer;
        }
    }
    return nil;
}

func scope_push_obj(p *Parser, name *u8, obj *Object) *VarScope {
    let var_scope *VarScope = alloc(typesize(VarScope));
    var_scope.name = name;
    var_scope.obj = obj;
    var_scope.outer = p.scope.var_scope;
    p.scope.var_scope = var_scope;
    return var_scope;
}

func find_object(p *Parser, tok *Token) *Object {
    let obj *Object = find_locals(p, tok);
    if obj == nil {
        obj = find_globals(p, tok);
    }
    return obj;
}

func new_initializer(node *Node) *Initializer {
    let init *Initializer = alloc(typesize(Initializer));
    if init == nil {
        eprintf("allocation faile\n");
        exit(1);
    }

    init.node = node;
    init.kind = InitKindNode;

    return init;
}

func parse_initializer(p *Parser) u0 {
    let init_start_token *Token = p.tokens;
    parser_skip(p, "{");

    let children *Vec = new_vec(10);

    let init *Initializer = alloc(typesize(Initializer));
    if init == nil {
        eprintf("memory allocation failed\n");
        exit(1);
    }
    init.kind = InitKindChildren;
    init.tok = init_start_token;

    while !is_token(p.tokens, "}") {
        if is_token(p.tokens, "{") {
            vec_append(children, parse_initializer(p));
        } else {
           let node *Node = parse_expr(p);
           add_type(p, node);
           vec_append(children, new_initializer(node));
        }

        if is_token(p.tokens, ",") {
            parser_skip(p, ",");
        } else {
            goto break;
        }
    }
break:
    parser_skip(p, "}");

    init.children = children;
    return init;
}

func build_initializer_node(p *Parser, lhs *Node, init_data *Initializer) *Node {
    let nodes *Vec = new_vec(10);

    if init_data.kind == InitKindChildren {
        let children *Vec = init_data.children;
        if lhs.ty.kind == TY_ARRAY {
            for let i i32 = 0; i < lhs.ty.array_len; i++ {
                let deref_lhs *Node = new_node(ND_DEREF);
                deref_lhs.lhs = new_binop(ND_ADD, lhs, new_node_num(lhs.ty.pointer_to.size * i));
                add_type(p, deref_lhs);

                if i >= children.len {
                    goto break;
                }

                let child_init *Initializer = vec_get(children, i);
                if child_init.kind == InitKindChildren {
                    vec_append(nodes, build_initializer_node(p, deref_lhs, child_init));
                } else if child_init.kind == InitKindNode {
                    vec_append(nodes, new_binop(ND_ASSIGN, deref_lhs, child_init.node));
                } else {
                    internal_error();
                }
            }
        } else if lhs.ty.kind == TY_STRUCT {
            for let i i32 = 0; i < lhs.ty.members.len; i++ {
                let struct_member *Member = vec_get(lhs.ty.members, i);

                let deref_lhs *Node = new_struct_access_node(ND_MEMBER_ACCESS, lhs, struct_member.offset, struct_member.ty);

                if i >= children.len {
                    goto break;
                }

                let child_init *Initializer = vec_get(children, i);
                if child_init.kind == InitKindChildren {
                    vec_append(nodes, build_initializer_node(p, deref_lhs, child_init));
                } else if child_init.kind == InitKindNode {
                    vec_append(nodes, new_binop(ND_ASSIGN, deref_lhs, child_init.node));
                } else {
                    internal_error();
                }
            }
        } else {
            print_error(init_data.tok, "initializer can only be used with array or struct types");
        }
    break:
    } else {
        internal_error();
    }

    let node *Node = new_node(ND_BLOCK);
    node.body = nodes;
    add_type(p, node);

    return node;
}

// inits Vec<Initializer>
func get_max_len_initializer(inits *Vec) *Initializer {
    let max_init *Initializer = nil;
    let max i32 = 0;

    for let i i32 = 0; i < inits.len; i++ {
        let init *Initializer = vec_get(inits, i);
        if init.kind == InitKindChildren {
            if max < init.children.len {
                max_init = init;
                max = init.children.len;
            }
        }
    }

    return max_init;
}

func resolve_variable_length_array_type(ty *Type, init *Initializer) i32 {
    if ty.kind == TY_ARRAY && ty.is_unsized_array {
        if init.kind == InitKindChildren {
            if ty.pointer_to.kind == TY_ARRAY {
                let init_child *Initializer = get_max_len_initializer(init.children);
                let length i32 = ty.array_len;
                let child_size i32 = 0;
                let size i32 = 0;
                if init_child != nil {
                    length = init.children.len;
                    if ty.has_array_len {
                        length = ty.array_len;
                    }
                    child_size = resolve_variable_length_array_type(ty.pointer_to, init_child);
                    size = length * child_size;
                } else {
                    if ty.has_array_len {
                        length = ty.array_len;
                    }
                }
                ty.size = size;
                ty.array_len = length;
                return ty.size;
            } else {
                let length i32 = init.children.len;
                if ty.has_array_len {
                    length = ty.array_len;
                }
                let child_size i32 = ty.pointer_to.size;
                let size i32 = length * child_size;
                ty.size = size;
                ty.array_len = length;
                return ty.size;
            }
        } else {
            internal_error();
        }
    } else {
        return ty.size;
    }
}

func parse_let(p *Parser) *Node {
    let node *Node;

    parser_skip(p, "let");

    let var_name_tok *Token = p.tokens;
    parser_next(p);

    let var_ty *Type = parse_ty(p);
    let var_name *u8 = get_token_lit(var_name_tok);
    let obj *Object = new_local_object(p, OBJ_VAR, var_name, var_ty, var_name_tok, false);

    if is_token(p.tokens, "=") {
        parser_skip(p, "=");

        let node_var *Node = new_node(ND_VAR);
        node_var.obj = obj;
        add_type(p, node_var);

        if is_token(p.tokens, "{") {
            let init_data *Initializer = parse_initializer(p);
            if node_var.ty.is_unsized_array {
                resolve_variable_length_array_type(node_var.ty, init_data);
            }
            node = build_initializer_node(p, node_var, init_data);
            parser_skip(p, ";");
        } else {
            node = new_binop(ND_ASSIGN, node_var, parse_expr_stmt(p));
        }

        return node;
    } else {
        parser_skip(p, ";");
        return nil;
    }
}

func parse_goto(p *Parser) *Node {
    parser_skip(p, "goto");

    let label_name *u8 = get_token_lit(p.tokens);
    parser_next(p);

    parser_skip(p, ";");

    let node *Node = new_node(ND_GOTO);
    node.label_name = label_name;
    return node;
}

func parse_if(p *Parser) *Node {
    parser_skip(p, "if");

    let node *Node = new_node(ND_IF);
    node.label_name = new_unique_label();
    node.cond = parse_expr(p);
    node.then_block = parse_block(p);

    if is_token(p.tokens, "else") {
        parser_next(p);
        node.else_block = parse_stmt(p);
    } else {
        node.else_block = new_node(ND_EMPTY);
    }

    return node;
}

func parse_return(p *Parser) *Node {
    parser_skip(p, "return");
    if is_token(p.tokens, ";") {
        parser_skip(p, ";");
        return new_node(ND_RETURN);
    }
    let node *Node = new_node(ND_RETURN);
    node.lhs = parse_expr_stmt(p);
    return node;
}

func parse_for(p *Parser) *Node {
    parser_skip(p, "for");
    let node *Node = new_node(ND_FOR);

    node.label_name = new_unique_label();

    if !is_token(p.tokens, "{") {
        enter_scope(p);
        if is_token(p.tokens, ";") {
            node.init = nil;
            parser_skip(p, ";");
        } else if is_token(p.tokens, "let") {
            node.init = parse_let(p);
        } else {
            node.init = parse_expr_stmt(p);
        }

        if is_token(p.tokens, ";") {
            node.cond = nil;
        } else {
            node.cond = parse_expr(p);
        }
        parser_skip(p, ";");

        if is_token(p.tokens, "{") {
            node.inc = nil;
        } else {
            node.inc = parse_expr(p);
        }
    } else {
        node.cond = node_true();
    }

    node.then_block = parse_block(p);

    leave_scope(p);

    return node;
}

func parse_while(p *Parser) *Node {
    parser_skip(p, "while");
    let node *Node = new_node(ND_FOR);

    node.label_name = new_unique_label();

    if !is_token(p.tokens, "{") {
        node.cond = parse_expr(p);
    } else {
        node.cond = node_true();
    }

    node.then_block = parse_block(p);
    return node;
}

func parse_label(p *Parser) *Node {
    let node *Node = new_node(ND_LABEL);
    let tok_lit *u8 = get_token_lit(p.tokens);
    node.label_name = tok_lit;

    parser_next(p);
    parser_skip(p, ":");

    return node;
}

func parse_switch(p *Parser) *Node {
    let switch_tok *Token = p.tokens;

    parser_skip(p, "switch");
    let node *Node = new_node(ND_SWITCH);

    node.label_name = new_unique_label();

    if p.current_switch != nil {
        node.outer = p.current_switch;
    }

    p.current_switch = node;

    node.cond = parse_expr(p);

    node.cases = new_vec(4);

    node.then_block = parse_block(p);

    if node.cases.len == 0 {
        print_error(switch_tok, "switch statement must have at least one case");
    }

    p.current_switch = node.outer;

    return node;
}

func parse_case(p *Parser) *Node {
    if p.current_switch == nil {
        print_error(p.tokens, "'case' used outside of a switch statement");
    }

    parser_skip(p, "case");
    let node *Node = new_node(ND_CASE);
    let save_cond_tok *Token = p.tokens;
    node.cond = parse_expr(p);
    if node.cond.kind != ND_NUM {
        print_error(save_cond_tok, "case value must be a integer constant");
    }
    node.label_name = new_unique_label();
    vec_append(p.current_switch.cases, node);

    if is_token(p.tokens, "...") {
        let case_range_node *Node = new_node(ND_CASE_RANGE);
        case_range_node.cases = new_vec(10);
        vec_append(case_range_node.cases, node);

        parser_next(p);
        let save_range_end_node_tok *Token = p.tokens;
        let range_end_node *Node = parse_expr(p);
        if range_end_node.kind != ND_NUM {
            print_error(save_range_end_node_tok, "case value must be a integer constant");
        }

        for let i i32 = node.cond.int_val+1; i <= range_end_node.int_val; i++ {
            let case_node *Node = new_node(ND_CASE);
            case_node.cond = new_node_num(i);
            case_node.label_name = new_unique_label();
            vec_append(p.current_switch.cases, case_node);
            vec_append(case_range_node.cases, case_node);
        }

        parser_skip(p, ":");
        return case_range_node;
    } else {
        parser_skip(p, ":");
    }

    return node;
}

func parse_stmt(p *Parser) *Node {
    if is_token(p.tokens, "switch") {
        return parse_switch(p);
    }
    if is_token(p.tokens, "case") {
        return parse_case(p);
    }
    if is_token(p.tokens, "let") {
        return parse_let(p);
    }
    if is_token(p.tokens, "goto") {
        return parse_goto(p);
    }
    if is_token(p.tokens, "if") {
        return parse_if(p);
    }
    if is_token(p.tokens, "for") {
        return parse_for(p);
    }
    if is_token(p.tokens, "while") {
        return parse_while(p);
    }
    if is_token(p.tokens, "return") {
        return parse_return(p);
    }
    if is_token(p.tokens, "{") {
        return parse_block(p);
    }
    if p.tokens.kind != TK_EOF {
        if is_token(p.tokens.next, ":") {
            return parse_label(p);
        }
    }

    return parse_expr_stmt(p);
}

func unkown_type_error(types *Vec, tok *Token, msg *u8) u0 {
    print_error_with_code(tok, msg);

    if types.len == 0 {
        exit(1);
    } else if types.len == 1 {
        eprintf("help: %d possibility:", types.len);
    } else {
        eprintf("help: %d possibilities:", types.len);
    }

    for let i i32 = 0; i < types.len; i++ {
        let type *Type = vec_get(types, i);
        if i+1 < types.len {
            eprintf(" `%s`,", type.name);
        } else {
            eprintf(" `%s`\n", type.name);
        }
    }

    exit(1);
}

func get_user_defined_type(p *Parser, tok *Token) *Type {
    for let i i32 = 0; i < p.user_defined_types.len; i++ {
        let ty *Type = vec_get(p.user_defined_types, i);
        if is_token(tok, ty.name) {
            return ty;
        }
    }
    return nil;
}

func new_builtin_type(kind TypeKind, size i32, name *u8, is_unsigned bool) *Type {
    let ty *Type = alloc(typesize(Type));
    if ty == nil {
        eprintf("memory allocation failed\n");
        exit(1);
    }
    ty.kind = kind;
    ty.size = size;
    ty.name = name;
    ty.pointer_to = nil;
    ty.is_unsigned = is_unsigned;
    return ty;
}

func new_pointer_type(base *Type) *Type {
    let ty *Type = alloc(typesize(Type));
    if ty == nil {
        eprintf("memory allocation failed\n");
        exit(1);
    }
    ty.kind = TY_PTR;
    ty.size = 8;
    ty.pointer_to = base;
    return ty;
}

func new_array_type(base *Type, len i32, is_unsized_array bool, has_array_len bool) *Type {
    let ty *Type = alloc(typesize(Type));
    if ty == nil {
        eprintf("memory allocation failed\n");
        exit(1);
    }
    ty.kind = TY_ARRAY;
    ty.size = base.size * len;
    ty.pointer_to = base;
    ty.array_len = len;
    ty.has_array_len = has_array_len;
    ty.is_unsized_array = is_unsized_array || base.is_unsized_array;
    return ty;
}

func new_func_type(params_types *Vec, return_type *Type, is_variadic bool) *Type {
    let ty *Type = alloc(typesize(Type));
    if ty == nil {
        eprintf("memory allocation failed\n");
        exit(1);
    }
    ty.kind = TY_FUNC;
    ty.size = 8;
    ty.params = params_types;
    ty.return_type = return_type;
    ty.is_variadic = is_variadic;
    return ty;
}

func cmp_type_vec(vec1 *Vec, vec2 *Vec) bool {
    if vec1.len != vec2.len {
        return false;
    }

    for let i i32 = 0; i < vec1.len; i++ {
        if !cmp_type(vec_get(vec1, i), vec_get(vec2, i)) {
            return false;
        }
    }

    return true;
}

func cmp_type(ty1 *Type, ty2 *Type) bool {
    if ty1 == nil || ty2 == nil {
        eprintf("internal error: this should not happen\n");
        exit(1);
    }

    if ty1.kind != ty2.kind {
        return false;
    }

    if ty1.kind == TY_FUNC {
        return cmp_type(ty1.return_type, ty2.return_type) && cmp_type_vec(ty1.params, ty2.params) && ty1.is_variadic == ty2.is_variadic;
    }

    if ty1.kind == TY_PTR {
        return cmp_type(ty1.pointer_to, ty2.pointer_to);
    }

    return ty1.size == ty2.size && ty1.is_unsigned == ty2.is_unsigned && str_equal(ty1.name, ty2.name);
}

func parse_params_types(p *Parser, types *Vec) bool {
    while !is_token(p.tokens, ")") {
        if is_token(p.tokens, "...") {
            parser_next(p);
            return true;
        } else {
            let ty *Type = parse_ty(p);
            if ty.kind == TY_ARRAY {
                ty = new_pointer_type(ty.pointer_to);
            }
            vec_append(types, ty);
        }
        if !is_token(p.tokens, ",") {
            goto break;
        }
        parser_next(p);
    }

break:

    return false;
}

func parse_ty(p *Parser) *Type {
    let type_name_tok *Token = p.tokens;

    parser_next(p);
    let ty *Type;

    if is_token(type_name_tok, "i64") { ty = p.ty_i64; }
    else if is_token(type_name_tok, "i32") { ty = p.ty_i32; }
    else if is_token(type_name_tok, "i16") { ty = p.ty_i16; }
    else if is_token(type_name_tok, "i8") { ty = p.ty_i8; }
    else if is_token(type_name_tok, "u64") { ty = p.ty_u64; }
    else if is_token(type_name_tok, "u32") { ty = p.ty_u32; }
    else if is_token(type_name_tok, "u16") { ty = p.ty_u16; }
    else if is_token(type_name_tok, "u8") { ty = p.ty_u8; }
    else if is_token(type_name_tok, "u0") { ty = p.ty_u0; }
    else if is_token(type_name_tok, "bool") { ty = p.ty_bool; }
    else if is_token(type_name_tok, "*") { ty = new_pointer_type(parse_ty(p)); }
    else if is_token(type_name_tok, "func") {
        // NOTE: A variable or function paramater typed as a function will be treated as a function pointer `*func()`
        parser_skip(p, "(");
        let types *Vec = new_vec(4);
        let is_variadic bool = parse_params_types(p, types);
        parser_skip(p, ")");
        ty = new_func_type(types, parse_ty(p), is_variadic);
        ty = new_pointer_type(ty);
    } else if is_token(type_name_tok, "[") {
        if p.tokens.kind != TK_NUM {
            parser_skip(p, "]");
            ty = new_array_type(parse_ty(p), 0, true, false);
            ty.is_unsized_array = true;
        } else {
            let array_len i32 = p.tokens.int_val;
            parser_next(p);
            parser_skip(p, "]");
            ty = new_array_type(parse_ty(p), array_len, false, true);
        }
    } else {
        ty = get_user_defined_type(p, type_name_tok);
        if ty == nil {
            unkown_type_error(p.user_defined_types, type_name_tok, "unkown type found");
        }
    }

    return ty;
}

func add_type_block(p *Parser, nodes *Vec) u0 {
    if nodes == nil {
        return;
    }
    for let i i32 = 0; i < nodes.len; i++ {
        let node *Node = vec_get(nodes, i);
        add_type(p, node);
    }
}

func add_type(p *Parser, node *Node) u0 {
    if node == nil || node.ty != nil {
        return;
    }

    add_type(p, node.lhs);
    add_type(p, node.rhs);
    add_type(p, node.init);
    add_type(p, node.cond);
    add_type(p, node.inc);

    add_type_block(p, node.body);
    add_type(p, node.then_block);
    add_type(p, node.else_block);

    add_type_block(p, node.args);

    if node.kind == ND_STR {
        node.ty = new_pointer_type(p.ty_i8);
        return;
    }

    if node.kind == ND_FUNC_CALL {
        if node.lhs.ty.kind == TY_PTR {
            node.ty = node.lhs.ty.pointer_to.return_type;
        } else {
            node.ty = node.lhs.ty.return_type;
        }
        return;
    }

    if (node.kind == ND_ADD || node.kind == ND_SUB
        || node.kind == ND_MUL || node.kind == ND_DIV
        || node.kind == ND_MOD || node.kind == ND_ASSIGN
        || node.kind == ND_SHL || node.kind == ND_SHR || node.kind == ND_MEMZERO) {
        node.ty = node.lhs.ty;
        return;
    }

    if (node.kind == ND_NOT || node.kind == ND_EQ
        || node.kind == ND_NE || node.kind == ND_LE
        || node.kind == ND_LT || node.kind == ND_GT
        || node.kind == ND_GE || node.kind == ND_LOGAND
        || node.kind == ND_LOGOR || node.kind == ND_NUM
        || node.kind == ND_AND || node.kind == ND_OR) {
        node.ty = p.ty_i32;
        return;
    }

    if node.kind == ND_VAR {
        node.ty = node.obj.ty;
        return;
    }

    if node.kind == ND_REF {
        if node.lhs.ty.kind == TY_ARRAY {
            node.ty = new_pointer_type(node.lhs.ty.pointer_to);
        } else {
            node.ty = new_pointer_type(node.lhs.ty);
        }
        return;
    }

    if node.kind == ND_DEREF {
        node.ty = node.lhs.ty.pointer_to;
        return;
    }

    if node.kind == ND_EXPR_STMT {
        node.ty = node.lhs.ty;
        return;
    }

    return;
}

func unexpected_token_error(expected *u8, tok *Token, msg *u8) u0 {
    print_error_with_code(tok, msg);
    let got *u8 = get_token_lit(tok);
    eprintf("help: expected `%s` but got `%s`\n", expected, got);
    exit(1);
}

func unkown_member_error(members *Vec, tok *Token, msg *u8) u0 {
    print_error_with_code(tok, msg);

    if members.len == 0 {
        exit(1);
    } else if members.len == 1 {
        eprintf("help: %d possibility:", members.len);
    } else {
        eprintf("help: %d possibilities:", members.len);
    }

    for let i i32 = 0; i < members.len; i++ {
        let member *Member = vec_get(members, i);
        if i+1 < members.len {
            eprintf(" `%s`,", member.name);
        } else {
            eprintf(" `%s`\n", member.name);
        }
    }

    exit(1);
}

func new_parser(tokens *Token) *Parser {
    let p *Parser = alloc(typesize(Parser));
    if p == nil {
        eprintf("memory allocation failed\n");
        exit(1);
    }
    p.tokens = tokens;
    p.locals = nil;
    p.user_defined_types = new_vec(4);

    p.ty_i64 = new_builtin_type(TY_I64, 8, "i64", false);
    p.ty_i32 = new_builtin_type(TY_I32, 4, "i32", false);
    p.ty_i16 = new_builtin_type(TY_I16, 2, "i16", false);
    p.ty_i8 = new_builtin_type(TY_I8, 1, "i8", false);
    p.ty_bool = new_builtin_type(TY_BOOL, 4, "bool", false);

    p.ty_u64 = new_builtin_type(TY_U64, 8, "u64", true);
    p.ty_u32 = new_builtin_type(TY_U32, 4, "u32", true);
    p.ty_u16 = new_builtin_type(TY_U16, 2, "u16", true);
    p.ty_u8 = new_builtin_type(TY_U8, 1, "u8", true);
    p.ty_u0 = new_builtin_type(TY_U0, 0, "u0", true);

    return p;
}

func parser_next(p *Parser) u0 {
    if p.tokens.next == nil {
        eprintf("internal error: this should not happen.");
        exit(1);
    }
    p.tokens = p.tokens.next;
    return;
}

func new_node(kind NodeKind) *Node {
    let node *Node = alloc(typesize(Node));
    if node == nil {
        eprintf("memory allocation failed\n");
        exit(1);
    }
    node.kind = kind;
    return node;
}

func parser_skip(p *Parser, str *u8) u0 {
    if is_token(p.tokens, str) {
        parser_next(p);
        return;
    }
    unexpected_token_error(str, p.tokens, "unexpected token");
}

func parse_func_call_args(p *Parser) *Vec {
    let args *Vec = new_vec(4);

    while !is_token(p.tokens, ")") {
        vec_append(args, parse_expr(p));
        if !is_token(p.tokens, ",") {
            goto break;
        }
        parser_next(p);
    }

break:
    return args;
}

func parse_sizeof(p *Parser) *Node {
    parser_skip(p, "sizeof");
    parser_skip(p, "(");
    let node *Node = parse_unary(p);
    parser_skip(p, ")");
    add_type(p, node);
    let size i32 = node.ty.size;

    node.kind = ND_NUM;
    node.int_val = size;
    node.ty = p.ty_i32;

    return node;
}

func parse_ident(p *Parser) *Node {
    let var_tok *Token = p.tokens;
    let var_node *Node = new_node(ND_VAR);
    let obj *Object = find_object(p, p.tokens);

    if obj == nil {
        print_error(var_tok, "unkown object");
    }

    var_node.obj = obj;

    parser_next(p);

    return var_node;
}

func new_node_num(n i32) *Node {
    let node *Node = new_node(ND_NUM);
    node.int_val = n;
    return node;
}

func parse_number(p *Parser) *Node {
    let node *Node;

    if p.tokens.kind == TK_NUM {
        node = new_node_num(p.tokens.int_val);
        parser_next(p);
    } else if p.tokens.kind == TK_STR {
        node = new_node(ND_STR);
        node.str_val = p.tokens.str_val;
        node.label_name = new_unique_label();
        parser_next(p);
    } else if is_token(p.tokens, "nil") {
        parser_next(p);
        node = new_node(ND_NUM);
        node.ty = p.ty_i32;
        node.int_val = 0;
    } else if is_token(p.tokens, "true") {
        parser_next(p);
        node = new_node(ND_NUM);
        node.ty = p.ty_bool;
        node.int_val = 1;
    } else if is_token(p.tokens, "false") {
        parser_next(p);
        node = new_node(ND_NUM);
        node.ty = p.ty_bool;
        node.int_val = 0;
    } else if is_token(p.tokens, "typesize") {
        node = new_node(ND_NUM);
        parser_next(p);
        parser_skip(p, "(");
        node.int_val = parse_ty(p).size;
        node.ty = p.ty_i32;
        parser_skip(p, ")");
    } else if is_token(p.tokens, "sizeof") {
        node = parse_sizeof(p);
    } else if p.tokens.kind == TK_IDENT {
        node = parse_ident(p);
    } else if is_token(p.tokens, "(") {
        parser_next(p);
        node = parse_expr(p);
        parser_skip(p, ")");
    } else {
        print_error(p.tokens, "expected number or identifier");
        exit(1);
    }
    return node;
}

func search_struct_member(members *Vec, exp_member_name *u8) *Member {
    for let i i32 = 0; i < members.len; i++ {
        let member *Member = vec_get(members, i);
        if str_equal(member.name, exp_member_name) {
            return member;
        }
    }
    return nil;
}

func new_struct_access_node(kind NodeKind, lhs *Node, offset i32, ty *Type) *Node {
    let node *Node = alloc(typesize(Node));

    node.kind = kind;
    node.lhs = lhs;
    node.offset = offset;
    node.ty = ty;

    return node;
}

func parse_deref(p *Parser) *Node {
    let tok *Token = p.tokens;
    parser_next(p);
    let node *Node = new_node(ND_DEREF);
    node.lhs = parse_unary(p);

    add_type(p, node.lhs);

    if node.lhs.ty.kind != TY_PTR && node.lhs.ty.kind != TY_ARRAY {
        print_error(tok, "invalid pointer dereference");
    }

    return node;
}

func new_binop(kind NodeKind, lhs *Node, rhs *Node) *Node {
    let node *Node = new_node(kind);
    if kind == ND_LOGAND || kind == ND_LOGOR {
        node.label_name = new_unique_label();
    }
    node.lhs = lhs;
    node.rhs = rhs;
    return node;
}

func params_length_without_argv_argc(ty *Type) i32 {
    if ty.is_variadic {
        return ty.params.len - 2;
    } else {
        return ty.params.len;
    }
}

func parse_ref(p *Parser) *Node {
    parser_skip(p, "&");
    let node *Node = new_node(ND_REF);
    node.lhs = parse_unary(p);
    return node;
}

func parse_not(p *Parser) *Node {
    parser_skip(p, "!");
    let node *Node = new_node(ND_NOT);
    node.lhs = parse_unary(p);
    return node;
}

func get_function_pointer_type(node *Node) *Type {
    let node_ty *Type = node.ty;
    if node_ty == nil {
        return nil;
    }
    if node_ty.kind == TY_FUNC {
        return node_ty;
    }
    if node_ty.kind == TY_PTR {
        let pointer_to *Type = node_ty.pointer_to;
        if pointer_to.kind == TY_FUNC {
            return pointer_to;
        }
    }
    return nil;
}

func parse_unary(p *Parser) *Node {
    if is_token(p.tokens, "*") {
        return parse_deref(p);
    }
    if is_token(p.tokens, "&") {
        return parse_ref(p);
    }
    if is_token(p.tokens, "!") {
        return parse_not(p);
    }

    let node *Node = parse_number(p);

    while {
        if is_token(p.tokens, "(") {
            let lpar_tok *Token = p.tokens;
            parser_skip(p, "(");

            add_type(p, node);

            let node_function_type *Type = get_function_pointer_type(node);
            if node_function_type == nil {
                print_error(lpar_tok, "cannot call a none function type object\n");
            }

            let func_call_node *Node = new_node(ND_FUNC_CALL);
            func_call_node.lhs = node;

            func_call_node.args = parse_func_call_args(p);

            let rpar_tok *Token = p.tokens;
            parser_skip(p, ")");

            if node_function_type.is_variadic {
                if func_call_node.args.len < params_length_without_argv_argc(node_function_type) {
                    print_error(lpar_tok, "The number of arguments does not match the function definition");
                }
            } else {
                if func_call_node.args.len != node_function_type.params.len {
                    print_error(lpar_tok, "The number of arguments does not match the function definition");
                }
            }

            node = func_call_node;
            goto continue;
        }
        let access_tok *Token = p.tokens;
        if is_token(p.tokens, "++") {
            parser_next(p);
            node = new_binop(ND_SUB, new_binop(ND_ASSIGN, node, new_binop(ND_ADD, node, new_node_num(1))), new_node_num(1));
            goto continue;
        }
        if is_token(p.tokens, "--") {
            parser_next(p);
            node = new_binop(ND_ADD, new_binop(ND_ASSIGN, node, new_binop(ND_SUB, node, new_node_num(1))), new_node_num(1));
            goto continue;
        }
        if is_token(p.tokens, "[") {
            add_type(p, node);
            parser_next(p);
            let index_number_node *Node = parse_expr(p);
            parser_skip(p, "]");

            if node.ty.kind != TY_PTR && node.ty.kind != TY_ARRAY {
                print_error(access_tok, "'[]' cannot be used on non-pointer type");
            }

            let base_number_node *Node = new_node(ND_NUM);
            base_number_node.int_val = node.ty.pointer_to.size;
            base_number_node.ty = p.ty_i32;

            let idx_pointer_arith *Node = new_binop(ND_MUL, index_number_node, base_number_node);
            node = new_binop(ND_ADD, node, idx_pointer_arith);

            node = new_struct_access_node(ND_DEREF, node, 0, nil);
            goto continue;
        }
        if is_token(p.tokens, ".") {
            parser_next(p);

            let member_name *u8 = get_token_lit(p.tokens);
            let member_tok *Token = p.tokens;
            let member *Member;

            parser_next(p);

            add_type(p, node);

            if node.ty.kind == TY_PTR {
                if node.ty.pointer_to.kind != TY_STRUCT {
                    print_error(access_tok, "cannot access member of non-struct type");
                }
                member = search_struct_member(node.ty.pointer_to.members, member_name);
                if member == nil {
                    eprintf("node.ty.pointer_to.name: %s\n", node.ty.pointer_to.name);
                    eprintf("member_name: %s\n", member_name);
                    eprintf("node.ty.pointer_to.members.len: %d\n", node.ty.pointer_to.members.len);
                    unkown_member_error(node.ty.pointer_to.members, member_tok, "member name not found");
                }
                node = new_struct_access_node(ND_DEREF, node, 0, node.ty.pointer_to);
            } else {
                if node.ty.kind != TY_STRUCT {
                    print_error(access_tok, "cannot access member of non-struct type");
                }
                member = search_struct_member(node.ty.members, member_name);
                if member == nil {
                    eprintf("member_name: %s\n", member_name);
                    eprintf("node.ty.members.len: %d\n", node.ty.members.len);
                    unkown_member_error(node.ty.members, member_tok, "member name not found");
                }
            }
            let offset i32 = member.offset;
            let member_ty *Type = member.ty;
            node = new_struct_access_node(ND_MEMBER_ACCESS, node, offset, member_ty);
            goto continue;
        }
        goto break;
        continue:
    }
    break:

    return node;
}

func parse_mul(p *Parser) *Node {
    let node *Node = parse_unary(p);

    while {
        if is_token(p.tokens, "*") {
            parser_next(p);
            node = new_binop(ND_MUL, node, parse_unary(p));
        } else if is_token(p.tokens, "/") {
            parser_next(p);
            node = new_binop(ND_DIV, node, parse_unary(p));
        } else if is_token(p.tokens, "%") {
            parser_next(p);
            node = new_binop(ND_MOD, node, parse_unary(p));
        } else {
            goto break;
        }
    }
break:

    return node;
}

func parse_add(p *Parser) *Node {
    let node *Node = parse_mul(p);

    while {
        if is_token(p.tokens, "+") {
            parser_next(p);
            node = new_binop(ND_ADD, node, parse_mul(p));
        } else if is_token(p.tokens, "-") {
            parser_next(p);
            node = new_binop(ND_SUB, node, parse_mul(p));
        } else {
            goto break;
        }
    }
break:

    return node;
}

func parse_shift(p *Parser) *Node {
    let node *Node = parse_add(p);

    while {
        if is_token(p.tokens, "<<") {
            parser_next(p);
            node = new_binop(ND_SHL, node, parse_add(p));
        } else if is_token(p.tokens, ">>") {
            parser_next(p);
            node = new_binop(ND_SHR, node, parse_add(p));
        } else {
            goto break;
        }
    }

break:
    return node;
}

func is_comparison_node(node *Node) bool {
    return
        node.kind == ND_LE ||
        node.kind == ND_GE ||
        node.kind == ND_LT ||
        node.kind == ND_GT ||
        node.kind == ND_EQ ||
        node.kind == ND_NE ||
        node.kind == ND_LOGAND;
}

func search_relational_rhs(node *Node) *Node {
    let rel_node *Node = node;
    while is_comparison_node(rel_node) {
        rel_node = rel_node.rhs;
    }

    return rel_node;
}

func search_relational_lhs(node *Node) *Node {
    let rel_node *Node = node;
    while is_comparison_node(rel_node) {
        rel_node = rel_node.lhs;
    }

    return rel_node;
}

func new_relational(kind NodeKind, lhs *Node, rhs *Node) *Node {
    let node *Node;

    if is_comparison_node(lhs) && is_comparison_node(rhs) {
        node = new_binop(kind, search_relational_rhs(lhs.rhs), search_relational_lhs(rhs.lhs));
        node = new_binop(ND_LOGAND, node, rhs);
        node = new_binop(ND_LOGAND, lhs, node);
        return node;
    }

    node = new_binop(kind, search_relational_rhs(lhs.rhs), rhs);
    node = new_binop(ND_LOGAND, lhs, node);
    return node;
}

func new_equality(kind NodeKind, lhs *Node, rhs *Node) *Node {
    let node *Node;
    if is_comparison_node(lhs) && is_comparison_node(rhs) {
        node = new_binop(kind, search_relational_rhs(lhs.rhs), search_relational_lhs(rhs.lhs));
        node = new_binop(ND_LOGAND, lhs, node);
        node = new_binop(ND_LOGAND, node, rhs);
        return node;
    }
    node = new_binop(kind, lhs, search_relational_lhs(rhs.lhs));
    node = new_binop(ND_LOGAND, node, rhs);
    return node;
}

func parse_relational(p *Parser) *Node {
    let node *Node = parse_shift(p);
    let rhs *Node;

    while {
        if is_token(p.tokens, "<=") {
            parser_next(p);
            rhs = parse_shift(p);
            if is_comparison_node(node) {
                node = new_relational(ND_LE, node, rhs);
            } else {
                node = new_binop(ND_LE, node, rhs);
            }
        } else if is_token(p.tokens, ">=") {
            parser_next(p);
            rhs = parse_shift(p);
            if is_comparison_node(node) {
                node = new_relational(ND_GE, node, rhs);
            } else {
                node = new_binop(ND_GE, node, rhs);
            }
        } else if is_token(p.tokens, "<") {
            parser_next(p);
            rhs = parse_shift(p);
            if is_comparison_node(node) {
                node = new_relational(ND_LT, node, rhs);
            } else {
                node = new_binop(ND_LT, node, rhs);
            }
        } else if is_token(p.tokens, ">") {
            parser_next(p);
            rhs = parse_shift(p);
            if is_comparison_node(node) {
                node = new_relational(ND_GT, node, rhs);
            } else {
                node = new_binop(ND_GT, node, rhs);
            }
        } else {
            goto break;
        }
    }
break:

    return node;
}

func parse_equality(p *Parser) *Node {
    let node *Node = parse_relational(p);
    let rhs *Node;

    while {
        if is_token(p.tokens, "==") {
            parser_next(p);
            rhs = parse_relational(p);
            if is_comparison_node(rhs) {
                node = new_equality(ND_EQ, node, rhs);
            } else if is_comparison_node(node) {
                node = new_relational(ND_EQ, node, rhs);
            } else {
                node = new_binop(ND_EQ, node, rhs);
            }
        } else if is_token(p.tokens, "!=") {
            parser_next(p);
            rhs = parse_relational(p);
            if is_comparison_node(rhs) {
                node = new_equality(ND_NE, node, rhs);
            } else if is_comparison_node(node) {
                node = new_relational(ND_NE, node, rhs);
            } else {
                node = new_binop(ND_NE, node, rhs);
            }
        } else {
            goto break;
        }
    }
break:

    return node;
}

func parse_and(p *Parser) *Node {
    let node *Node = parse_equality(p);
    while is_token(p.tokens, "&") {
        parser_next(p);
        node = new_binop(ND_AND, node, parse_equality(p));
    }
    return node;
}

func parse_or(p *Parser) *Node {
    let node *Node = parse_and(p);
    while is_token(p.tokens, "|") {
        parser_next(p);
        node = new_binop(ND_OR, node, parse_and(p));
    }
    return node;
}

func parse_logand(p *Parser) *Node {
    let node *Node = parse_or(p);
    while is_token(p.tokens, "&&") {
        parser_next(p);
        node = new_binop(ND_LOGAND, node, parse_or(p));
    }
    return node;
}

func parse_logor(p *Parser) *Node {
    let node *Node = parse_logand(p);
    while is_token(p.tokens, "||") {
        parser_next(p);
        node = new_binop(ND_LOGOR, node, parse_logand(p));
    }
    return node;
}

func parse_expr(p *Parser) *Node {
    let node *Node = parse_logor(p);
    if is_token(p.tokens, "=") {
        parser_next(p);
        node = new_binop(ND_ASSIGN, node, parse_expr(p));
    }
    return node;
}

func parse_expr_stmt(p *Parser) *Node {
    let node *Node = new_node(ND_EXPR_STMT);
    node.lhs = parse_expr(p);
    parser_skip(p, ";");
    return node;
}

func parse_block(p *Parser) *Node {
    let node *Node = new_node(ND_BLOCK);

    let stmts *Vec = new_vec(4);

    parser_skip(p, "{");

    enter_scope(p);

    while !is_token(p.tokens, "}") {
        let stmt *Node = parse_stmt(p);
        if stmt != nil {
            add_type(p, stmt);
            vec_append(stmts, stmt);
        }
    }

    leave_scope(p);

    parser_skip(p, "}");

    node.body = stmts;

    return node;
}

func node_true() *Node {
    let node *Node = new_node(ND_NUM);
    node.int_val = 1;
    return node;
}

func new_member(name *u8, ty *Type) *Member {
    let member *Member = alloc(typesize(Member));
    member.name = name;
    member.ty = ty;
    return member;
}

func calc_sizof_struct_members(members *Vec) i32 {
    let offset i32 = 0;

    for let i i32 = 0; i < members.len; i++ {
        let member *Member = vec_get(members, i);
        if member.ty.size <= 8 && align_to(offset, 8) < align_to(offset + member.ty.size, 8) {
            let new_offset i32 = align_to(offset, 8);
            member.padding = new_offset - offset;
            offset = new_offset;
        }
        member.offset = offset;
        offset = offset + member.ty.size;
    }

    return align_to(offset, 8);
}

func parse_struct(p *Parser) u0 {
    parser_skip(p, "struct");
    let name_tok *Token = p.tokens;
    parser_next(p);

    let members *Vec = new_vec(4);

    let ty *Type = alloc(typesize(Type));
    ty.kind = TY_STRUCT;
    ty.name = get_token_lit(name_tok);
    ty.size = 0;
    ty.members = members;

    let user_defined_struct *Type = get_user_defined_type(p, name_tok);

    if user_defined_struct == nil {
        vec_append(p.user_defined_types, ty);
    }

    if is_token(p.tokens, ";") {
        if user_defined_struct == nil {
            ty.is_declaration = true;
        }
        parser_skip(p, ";");
    } else {
        parser_skip(p, "{");
        while !is_token(p.tokens, "}") {
            let member_name *u8 = get_token_lit(p.tokens);
            parser_next(p);
            vec_append(members, new_member(member_name, parse_ty(p)));
            parser_skip(p, ",");
        }
        parser_skip(p, "}");

        let struct_size i32 = calc_sizof_struct_members(members);

        if user_defined_struct == nil {
            ty.size = struct_size;
            ty.members = members;
        } else if !user_defined_struct.is_declaration {
            print_error(name_tok, "struct is already defined");
        } else {
            user_defined_struct.members = members;
            user_defined_struct.size = struct_size;
            user_defined_struct.is_declaration = false;
        }
    }
}

func parse_function_params(p *Parser, types *Vec, params *Vec) bool {
    let is_variadic bool = false;

    parser_skip(p, "(");

    while !is_token(p.tokens, ")") {
        let params_name *u8 = get_token_lit(p.tokens);
        let params_name_tok *Token = p.tokens;
        parser_next(p);

        let ty *Type;
        let ty_tok *Token = p.tokens;
        if str_equal(params_name, "...") {
            if !is_token(p.tokens, ")") {
                print_error(params_name_tok, "must be at the end of the paramaters");
            }
            is_variadic = true;

            vec_append(types, p.ty_i64);
            vec_append(params, new_local_object(p, OBJ_VAR, "argc", p.ty_i32, params_name_tok, true));

            ty = new_pointer_type(p.ty_i64);
            vec_append(types, ty);
            vec_append(params, new_local_object(p, OBJ_VAR, "argv", ty, params_name_tok, true));
        } else {
            ty = parse_ty(p);
            if ty.kind == TY_STRUCT {
                print_error(ty_tok, "unsupported feature: struct as function parameter");
            }
            if ty.kind == TY_ARRAY {
                ty = new_pointer_type(ty.pointer_to);
            }
            vec_append(types, ty);
            vec_append(params, new_local_object(p, OBJ_VAR, params_name, ty, params_name_tok, true));

            if !is_token(p.tokens, ")") && !is_token(p.tokens, ",") {
                goto break;
            } else if !is_token(p.tokens, ")") {
                parser_skip(p, ",");
            }
        }
    }

break:

    parser_skip(p, ")");

    return is_variadic;
}

func add_global_object(p *Parser, obj *Object) u0 {
    obj.next = p.globals;
    p.globals = obj;
}

func parse_func(p *Parser) u0 {
    parser_skip(p, "func");

    p.locals = nil;
    enter_scope(p);

    let name_tok *Token = p.tokens;
    parser_next(p);

    let types *Vec = new_vec(4);
    let params *Vec = new_vec(4);
    let is_variadic bool = parse_function_params(p, types, params);
    let save_return_ty_tok *Token = p.tokens;
    let return_ty *Type = parse_ty(p);
    let fn *Object = find_globals(p, name_tok);

    if fn != nil {
        if !cmp_func_params(fn.params, params) {
            print_error(name_tok, "function arguments do not match the prototype");
        }
        if !cmp_type(return_ty, fn.ty.return_type) {
            print_error(name_tok, "function return type does not match the prototype");
        }
    }

    if return_ty.kind == TY_STRUCT {
        print_error(save_return_ty_tok, "unsupported feature: function returning struct");
    }

    let is_declaration bool = false;

    if is_token(p.tokens, ";") {
        parser_skip(p, ";");
        is_declaration = true;
    }

    if fn == nil {
        fn = alloc(typesize(Object));
        if fn == nil {
            eprintf("memory allocation failed\n");
        }
        fn.kind = OBJ_FUNC;
        fn.name = get_token_lit(name_tok);
        fn.params = params;
        fn.is_global = true;
        fn.ty = new_func_type(types, return_ty, is_variadic);
        add_global_object(p, fn);
        if is_declaration {
            fn.is_declaration = true;
            fn.locals = p.locals;
        } else {
            fn.body = parse_block(p);
            fn.locals = p.locals;
        }
    } else if fn.is_declaration && !is_declaration {
        fn.is_declaration = false;
        fn.body = parse_block(p);
        fn.locals = p.locals;
    } else if !is_declaration {
        print_error(name_tok, "function is already defined somewhere");
    }

    leave_scope(p);
}

func new_gvar_relocation_str(node *Node, pos i32) *Relocation {
    let rel *Relocation = alloc(typesize(Relocation));
    if rel == nil {
        eprintf("memory allocation failed\n");
        exit(1);
    }
    rel.kind = RELOC_STR;
    rel.pos = pos;
    rel.node = node;
    rel.addend = 0;
    return rel;
}

func new_gvar_relocation_var(node *Node, pos i32) *Relocation {
    let rel *Relocation = alloc(typesize(Relocation));
    if rel == nil {
        eprintf("memory allocation failed\n");
        exit(1);
    }
    rel.kind = RELOC_VAR;
    rel.pos = pos;
    rel.node = node;
    rel.addend = 0;
    return rel;
}

func write_buf(buf *u8, val u64, size i32) u0 {
    if size == 1 {
        *buf = val;
    } else if size == 2 {
        let buf2 *u16 = buf;
        *buf2 = val;
    } else if size == 4 {
        let buf2 *u32 = buf;
        *buf2 = val;
    } else if size == 8 {
        let buf2 *u64 = buf;
        *buf2 = val;
    } else {
        internal_error();
    }
}

func eval2(node *Node, str_reloc **Relocation, pos i32) i64 {
    if node.kind == ND_VAR {
        *str_reloc = new_gvar_relocation_var(node, pos);
        return 0;
    }
    if node.kind == ND_MEMBER_ACCESS {
        eval2(node.lhs, str_reloc, pos);
        (*str_reloc).addend = (*str_reloc).addend + node.offset;
        return 0;
    }
    internal_error();
}

func eval(node *Node, str_reloc **Relocation, pos i32) i64 {
    switch node.kind {
    case ND_NUM:
        return node.int_val;
    case ND_STR:
        if *str_reloc {
            eprintf("error: gvar init expected constant; todo: error message\n");
            exit(1);
        }
        *str_reloc = new_gvar_relocation_str(node, pos);
        return 0;
    case ND_VAR:
        if *str_reloc {
            eprintf("error: gvar init expected constant; todo: error message\n");
            exit(1);
        }
        if node.obj.ty.kind != TY_ARRAY && node.obj.ty.kind != TY_FUNC {
            eprintf("invalid initializer ty.kind %d\n", node.obj.ty.kind);
            exit(1);
        }

        *str_reloc = new_gvar_relocation_var(node, pos);
        return 0;
    case ND_REF:
        if node.lhs.kind == ND_VAR {
            *str_reloc = new_gvar_relocation_var(node.lhs, pos);
            return 0;
        }
        if node.lhs.kind == ND_MEMBER_ACCESS {
            eval2(node.lhs, str_reloc, pos);
            return 0;
        }
        internal_error();
    case ND_ADD:
        return eval(node.lhs, str_reloc, pos) + eval(node.rhs, str_reloc, pos);
    case ND_SUB:
        return eval(node.lhs, str_reloc, pos) - eval(node.rhs, str_reloc, pos);
    case ND_DIV:
        return eval(node.lhs, str_reloc, pos) / eval(node.rhs, str_reloc, pos);
    case ND_MUL:
        return eval(node.lhs, str_reloc, pos) * eval(node.rhs, str_reloc, pos);
    case ND_MOD:
        return eval(node.lhs, str_reloc, pos) % eval(node.rhs, str_reloc, pos);
    case ND_EQ:
        return eval(node.lhs, str_reloc, pos) == eval(node.rhs, str_reloc, pos);
    case ND_NE:
        return eval(node.lhs, str_reloc, pos) != eval(node.rhs, str_reloc, pos);
    case ND_LT:
        return eval(node.lhs, str_reloc, pos) < eval(node.rhs, str_reloc, pos);
    case ND_LE:
        return eval(node.lhs, str_reloc, pos) <= eval(node.rhs, str_reloc, pos);
    case ND_NOT:
        return !eval(node.lhs, str_reloc, pos);
    case ND_LOGOR:
        return eval(node.lhs, str_reloc, pos) || eval(node.rhs, str_reloc, pos);
    }
    eprintf("error: gvar init expected constant; todo: error message\n");
    exit(1);
}

func gvar_build_init_node(ty *Type, mem *u8, init_data *Initializer, relocs *Vec, pos i32) u0 {
    if init_data.kind != InitKindChildren {
        internal_error();
    }

    let children *Vec = init_data.children;

    if ty.kind == TY_ARRAY {
        for let i i32 = 0; i < ty.array_len && i < children.len; i++ {
            let child_init *Initializer = vec_get(children, i);
            if child_init.kind == InitKindChildren {
                gvar_build_init_node(ty.pointer_to, mem, child_init, relocs, pos + ty.pointer_to.size * i);
            } else if child_init.kind == InitKindNode {
                let rel *Relocation = nil;
                let val u64 = eval(child_init.node, &rel, pos);
                if rel != nil {
                    rel.addend = val + rel.addend;
                    vec_append(relocs, rel);
                } else {
                    write_buf(mem + pos, val, ty.pointer_to.size);
                }
                pos = pos + ty.pointer_to.size;
            } else {
                internal_error();
            }
        }
    } else if ty.kind == TY_STRUCT {
        for let i i32 = 0; i < ty.members.len && i < children.len; i++ {
            let member *Member = vec_get(ty.members, i);
            pos = member.padding + pos;
            let child_init *Initializer = vec_get(children, i);
            if child_init.kind == InitKindChildren {
                gvar_build_init_node(member.ty, mem, child_init, relocs, pos);
            } else if child_init.kind == InitKindNode {
                let rel *Relocation = nil;
                let val u64 = eval(child_init.node, &rel, pos);
                if rel != nil {
                    rel.addend = val + rel.addend;
                    vec_append(relocs, rel);
                } else {
                    write_buf(mem + pos, val, member.ty.size);
                }
                pos = pos + member.ty.size;
            } else {
                internal_error();
            }
        }
    } else {
        print_error(init_data.tok, "initializer can only be used with array or struct types");
    }
}

func parse_global_let(p *Parser) u0 {
    parser_skip(p, "let");
    let name *u8 = get_token_lit(p.tokens);
    parser_next(p);
    let ty *Type = parse_ty(p);
    let obj *Object = alloc(typesize(Object));
    if obj == nil {
        eprintf("memory allocation failed\n");
    }
    obj.kind = OBJ_VAR;
    obj.name = name;
    obj.ty = ty;
    obj.is_global = true;
    if !is_token(p.tokens, ";") {
        parser_skip(p, "=");
        if is_token(p.tokens, "{") {
            let init_data *Initializer = parse_initializer(p);
            if ty.is_unsized_array {
                resolve_variable_length_array_type(ty, init_data);
            }
            let gvar_mem *u8 = alloc(ty.size);
            if gvar_mem == nil {
                eprintf("memory allocation failed\n");
                exit(1);
            }
            let relocs *Vec = new_vec(10);
            gvar_build_init_node(ty, gvar_mem, init_data, relocs, 0);
            obj.gvar_mem = gvar_mem;
            obj.relocs = relocs;
        } else {
            let gval_expr_node *Node = parse_expr(p);
            let gvar_mem *u8 = alloc(ty.size);
            let relocs *Vec = new_vec(10);
            let str_rel *Relocation = nil;
            let val u64 = eval(gval_expr_node, &str_rel, 0);
            if str_rel != nil {
                str_rel.addend = val;
                vec_append(relocs, str_rel);
            } else {
                if ty.size > 8 {
                    add_type(p, gval_expr_node);
                    write_buf(gvar_mem, val, gval_expr_node.ty.size);
                } else {
                    write_buf(gvar_mem, val, ty.size);
                }
            }
            obj.relocs = relocs;
            obj.gvar_mem = gvar_mem;
        }
    }
    parser_skip(p, ";");
    add_global_object(p, obj);
}

func parse(p *Parser) u0 {
    while p.tokens.kind != TK_EOF {
        if is_token(p.tokens, "func") {
            parse_func(p);
        } else if is_token(p.tokens, "let") {
            parse_global_let(p);
        } else if is_token(p.tokens, "struct") {
            parse_struct(p);
        } else {
            print_error(p.tokens, "non-declaration statement outside function body");
        }
    }
}
